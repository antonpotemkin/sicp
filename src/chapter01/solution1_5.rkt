#lang racket/base

(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))

(provide p)
(provide test)

; (test 0 (p))
; Если интерпретатор использует аппликативный порядок вычисления, то сначала будет вычисляться аргумент (p),
; в результате получится бесконечная рекурсия из-за вызова функции самой себя
; Если интерпретатор использует аппликативный порядок вычисления, то вернется 0
